{"author":{"id":"2d08e4816aca0a07db9878f126b0e7f6d6f1362eb9bc4804be6b33ff8d0a19ec"},"ops":[{"type":3,"timestamp":1732875633,"nonce":"ssAhg/zJdIBmU30YIQkSMof2Hbw=","metadata":{"github-id":"IC_kwDOJl1IZM6VdYLp","github-url":"https://github.com/nikitabobko/AeroSpace/issues/771#issuecomment-2507506409"},"message":"I still have no idea why it happens, and I still can't reproduce it.\n\nIf somebody is up for the journey, you can try to build AeroSpace from sources with the following patch with the debugger attached:\n```diff\ndiff --git a/Sources/AppBundle/GlobalObserver.swift b/Sources/AppBundle/GlobalObserver.swift\nindex 9f3cfd7..91736bb 100644\n--- a/Sources/AppBundle/GlobalObserver.swift\n+++ b/Sources/AppBundle/GlobalObserver.swift\n@@ -4,9 +4,9 @@ class GlobalObserver {\n     private static func onNotif(_ notification: Notification) {\n         // Third line of defence against lock screen window. See: closedWindowsCache\n         // Second and third lines of defence are technically needed only to avoid potential flickering\n-        if (notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication)?.bundleIdentifier == lockScreenAppBundleId {\n-            return\n-        }\n+        // if (notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication)?.bundleIdentifier == lockScreenAppBundleId {\n+        //     return\n+        // }\n         refreshAndLayout(screenIsDefinitelyUnlocked: false)\n     }\n \ndiff --git a/Sources/AppBundle/layout/refresh.swift b/Sources/AppBundle/layout/refresh.swift\nindex 34023bb..add23a7 100644\n--- a/Sources/AppBundle/layout/refresh.swift\n+++ b/Sources/AppBundle/layout/refresh.swift\n@@ -60,11 +60,11 @@ private func gc() {\n func gcWindows() {\n     // Second line of defence against lock screen. See the first line of defence: closedWindowsCache\n     // Second and third lines of defence are technically needed only to avoid potential flickering\n-    if NSWorkspace.shared.frontmostApplication?.bundleIdentifier == lockScreenAppBundleId { return }\n+    // if NSWorkspace.shared.frontmostApplication?.bundleIdentifier == lockScreenAppBundleId { return }\n     let toKill = MacWindow.allWindowsMap.filter { $0.value.axWindow.containingWindowId() == nil }\n     // If all windows are \"unobservable\", it's highly propable that loginwindow might be still active and we are still\n     // recovering from unlock\n-    if toKill.count == MacWindow.allWindowsMap.count { return }\n+    // if toKill.count == MacWindow.allWindowsMap.count { return }\n     for window in toKill {\n         window.value.garbageCollect(skipClosedWindowsCache: false)\n     }\ndiff --git a/Sources/AppBundle/tree/MacApp.swift b/Sources/AppBundle/tree/MacApp.swift\nindex 936413e..da39d5a 100644\n--- a/Sources/AppBundle/tree/MacApp.swift\n+++ b/Sources/AppBundle/tree/MacApp.swift\n@@ -19,9 +19,9 @@ final class MacApp: AbstractApp {\n     fileprivate static func get(_ nsApp: NSRunningApplication) -\u003e MacApp? {\n         // Don't perceive any of the lock screen windows as real windows\n         // Otherwise, false positive ax notifications might trigger that lead to gcWindows\n-        if nsApp.bundleIdentifier == lockScreenAppBundleId {\n-            return nil\n-        }\n+        // if nsApp.bundleIdentifier == lockScreenAppBundleId {\n+        //     return nil\n+        // }\n         let pid = nsApp.processIdentifier\n         if let existing = allAppsMap[pid] {\n             return existing\n```\n\nThe patch removes all heuristic code that tries to detect locked screen. By droping the heuristics you should make the crash more probable to reproduce (In the best case scenario, it should make the bug 100% reproducible)\n\nThe problematic line of code is: https://github.com/nikitabobko/AeroSpace/blob/d172dfd8a92f2d339f3d46a12a297e43e80768ca/Sources/AppBundle/tree/frozen/closedWindowsCache.swift#L68\n\nIt should never crash because `rootTilingContainer` always returns definetely bound `TreeNode` (\"bound\" means that the node has its parent). It is somewhat obvious that the node is bound by reading the source code of `rootTilingContainer`. Nevertheless, your crash reports say that `unbindFromParent` panicked, since the node was already unbound\n\n---\n\nThe low effort fix for the crash could be:\n\n```diff\ndiff --git a/Sources/AppBundle/tree/TreeNode.swift b/Sources/AppBundle/tree/TreeNode.swift\nindex 2ea3775..d3c661e 100644\n--- a/Sources/AppBundle/tree/TreeNode.swift\n+++ b/Sources/AppBundle/tree/TreeNode.swift\n@@ -89,7 +89,8 @@ class TreeNode: Equatable {\n         return result\n     }\n \n-    private func unbindIfBound() -\u003e BindingData? {\n+    @discardableResult\n+    func unbindIfBound() -\u003e BindingData? {\n         guard let _parent else { return nil }\n \n         let index = _parent._children.remove(element: self) ?? errorT(\"Can't find child in its parent\")\ndiff --git a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\nindex 1e9539f..db0ff5c 100644\n--- a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n+++ b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n@@ -65,7 +65,7 @@ func restoreClosedWindowsCacheIfNeeded(newlyDetectedWindow: Window) -\u003e Bool {\n             MacWindow.get(byId: frozenWindow.id)?.bindAsFloatingWindow(to: workspace)\n         }\n         let orphans = workspace.rootTilingContainer.allLeafWindowsRecursive\n-        workspace.rootTilingContainer.unbindFromParent()\n+        workspace.rootTilingContainer.unbindIfBound()\n         restoreTreeRecursive(frozenContainer: frozenWorkspace.rootTilingNode, parent: workspace, index: INDEX_BIND_LAST)\n         for window in (orphans - workspace.rootTilingContainer.allLeafWindowsRecursive) {\n             window.relayoutWindow(on: workspace, forceTile: true)\n``` \n\nBut it will fix only symptoms, not the root cause, because some invariants will still be broken","files":null},{"type":6,"timestamp":1732876564,"nonce":"/aJCilQnmuEG52Ttg0Avwme1+p0=","metadata":{"github-id":"UCE_lALOJl1IZM6VdYLpzlZkJmA"},"target":"c6b426b4a3157f8959239a5ec7fbfabb02c5ace3780ab21fb3276aa37246fe86","message":"I still have no idea why it happens, and I still can't reproduce it.\n\nIf somebody is up for the journey, you can try to build AeroSpace from sources with the following patch with the debugger attached (I recommend using Xcode):\n```diff\ndiff --git a/Sources/AppBundle/GlobalObserver.swift b/Sources/AppBundle/GlobalObserver.swift\nindex 9f3cfd7..91736bb 100644\n--- a/Sources/AppBundle/GlobalObserver.swift\n+++ b/Sources/AppBundle/GlobalObserver.swift\n@@ -4,9 +4,9 @@ class GlobalObserver {\n     private static func onNotif(_ notification: Notification) {\n         // Third line of defence against lock screen window. See: closedWindowsCache\n         // Second and third lines of defence are technically needed only to avoid potential flickering\n-        if (notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication)?.bundleIdentifier == lockScreenAppBundleId {\n-            return\n-        }\n+        // if (notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication)?.bundleIdentifier == lockScreenAppBundleId {\n+        //     return\n+        // }\n         refreshAndLayout(screenIsDefinitelyUnlocked: false)\n     }\n \ndiff --git a/Sources/AppBundle/layout/refresh.swift b/Sources/AppBundle/layout/refresh.swift\nindex 34023bb..add23a7 100644\n--- a/Sources/AppBundle/layout/refresh.swift\n+++ b/Sources/AppBundle/layout/refresh.swift\n@@ -60,11 +60,11 @@ private func gc() {\n func gcWindows() {\n     // Second line of defence against lock screen. See the first line of defence: closedWindowsCache\n     // Second and third lines of defence are technically needed only to avoid potential flickering\n-    if NSWorkspace.shared.frontmostApplication?.bundleIdentifier == lockScreenAppBundleId { return }\n+    // if NSWorkspace.shared.frontmostApplication?.bundleIdentifier == lockScreenAppBundleId { return }\n     let toKill = MacWindow.allWindowsMap.filter { $0.value.axWindow.containingWindowId() == nil }\n     // If all windows are \"unobservable\", it's highly propable that loginwindow might be still active and we are still\n     // recovering from unlock\n-    if toKill.count == MacWindow.allWindowsMap.count { return }\n+    // if toKill.count == MacWindow.allWindowsMap.count { return }\n     for window in toKill {\n         window.value.garbageCollect(skipClosedWindowsCache: false)\n     }\ndiff --git a/Sources/AppBundle/tree/MacApp.swift b/Sources/AppBundle/tree/MacApp.swift\nindex 936413e..da39d5a 100644\n--- a/Sources/AppBundle/tree/MacApp.swift\n+++ b/Sources/AppBundle/tree/MacApp.swift\n@@ -19,9 +19,9 @@ final class MacApp: AbstractApp {\n     fileprivate static func get(_ nsApp: NSRunningApplication) -\u003e MacApp? {\n         // Don't perceive any of the lock screen windows as real windows\n         // Otherwise, false positive ax notifications might trigger that lead to gcWindows\n-        if nsApp.bundleIdentifier == lockScreenAppBundleId {\n-            return nil\n-        }\n+        // if nsApp.bundleIdentifier == lockScreenAppBundleId {\n+        //     return nil\n+        // }\n         let pid = nsApp.processIdentifier\n         if let existing = allAppsMap[pid] {\n             return existing\n```\n\nThe patch removes all heuristic code that tries to detect locked screen. By droping the heuristics you should make the crash more probable to reproduce (In the best case scenario, it should make the bug 100% reproducible)\n\nThe problematic line of code is: https://github.com/nikitabobko/AeroSpace/blob/d172dfd8a92f2d339f3d46a12a297e43e80768ca/Sources/AppBundle/tree/frozen/closedWindowsCache.swift#L68\n\nIt should never crash because `rootTilingContainer` always returns definetely bound `TreeNode` (\"bound\" means that the node has its parent). It is somewhat obvious that the node is bound by reading the source code of `rootTilingContainer`. Nevertheless, your crash reports say that `unbindFromParent` panicked, since the node was already unbound\n\n---\n\nThe low effort fix for the crash could be:\n\n```diff\ndiff --git a/Sources/AppBundle/tree/TreeNode.swift b/Sources/AppBundle/tree/TreeNode.swift\nindex 2ea3775..d3c661e 100644\n--- a/Sources/AppBundle/tree/TreeNode.swift\n+++ b/Sources/AppBundle/tree/TreeNode.swift\n@@ -89,7 +89,8 @@ class TreeNode: Equatable {\n         return result\n     }\n \n-    private func unbindIfBound() -\u003e BindingData? {\n+    @discardableResult\n+    func unbindIfBound() -\u003e BindingData? {\n         guard let _parent else { return nil }\n \n         let index = _parent._children.remove(element: self) ?? errorT(\"Can't find child in its parent\")\ndiff --git a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\nindex 1e9539f..db0ff5c 100644\n--- a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n+++ b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n@@ -65,7 +65,7 @@ func restoreClosedWindowsCacheIfNeeded(newlyDetectedWindow: Window) -\u003e Bool {\n             MacWindow.get(byId: frozenWindow.id)?.bindAsFloatingWindow(to: workspace)\n         }\n         let orphans = workspace.rootTilingContainer.allLeafWindowsRecursive\n-        workspace.rootTilingContainer.unbindFromParent()\n+        workspace.rootTilingContainer.unbindIfBound()\n         restoreTreeRecursive(frozenContainer: frozenWorkspace.rootTilingNode, parent: workspace, index: INDEX_BIND_LAST)\n         for window in (orphans - workspace.rootTilingContainer.allLeafWindowsRecursive) {\n             window.relayoutWindow(on: workspace, forceTile: true)\n``` \n\nBut it will fix only symptoms, not the root cause, because some invariants will still be broken","files":null},{"type":3,"timestamp":1732876504,"nonce":"hwfLLkfeIVgyqwhi7mZuz7wZ5tA=","metadata":{"github-id":"IC_kwDOJl1IZM6Vdei0","github-url":"https://github.com/nikitabobko/AeroSpace/issues/771#issuecomment-2507532468"},"message":"The only case when `restoreClosedWindowsCacheIfNeeded` is called is when macOS decides to reuse window ID from the previously closed window for the newly opened window. The only reasonable case known to me when it might happen is when you lock/unlock the screen. (when you lock and unlock the screen, from macOS APIs POV, windows technically \"close\" and then automatically reopen when you unlock the screen with the same window IDs). AeroSpace relies on that fact that window IDs are reused to restore windows to where they were before you locked the screen.\n\nThat's why it's weird for me to hear that people observe the crash when they unplug the dock.\n\nYou can try to debug the following, if you observe the crash in cases other than lock/unlock the screen:\n```diff\ndiff --git a/Sources/AppBundle/tree/MacWindow.swift b/Sources/AppBundle/tree/MacWindow.swift\nindex 321fa2b..11a126e 100644\n--- a/Sources/AppBundle/tree/MacWindow.swift\n+++ b/Sources/AppBundle/tree/MacWindow.swift\n@@ -63,7 +63,11 @@ final class MacWindow: Window, CustomStringConvertible {\n     // skipClosedWindowsCache is an optimization when it's definitely not necessary to cache closed window.\n     //                        If you are unsure, it's better to pass `false`\n     func garbageCollect(skipClosedWindowsCache: Bool) {\n-        if !skipClosedWindowsCache { cacheClosedWindowIfNeeded(window: self) }\n+        if !skipClosedWindowsCache {\n+            // The window will be recorded to closedWindowsCache, to potentially restore it from the cache if it turns out that the reason for closing the window is locking the screen\n+            print(\"--- Window \\(app.name) \\(windowId) is about to die and will be recorded to closedWindowsCache.\")\n+            cacheClosedWindowIfNeeded(window: self)\n+        }\n         if MacWindow.allWindowsMap.removeValue(forKey: windowId) == nil {\n             return\n         }\ndiff --git a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\nindex 1e9539f..8ab361d 100644\n--- a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n+++ b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n@@ -50,6 +50,7 @@ func restoreClosedWindowsCacheIfNeeded(newlyDetectedWindow: Window) -\u003e Bool {\n     if !closedWindowsCache.windowIds.contains(newlyDetectedWindow.windowId) {\n         return false\n     }\n+    print(\"--- macOS decided to reuse window ID for this window: \\(newlyDetectedWindow). Normally this should only happen when you lock/unlock the screen. It's your case, right, right?...\")\n     let monitors = monitors\n     let topLeftCornerToMonitor = monitors.grouped { $0.rect.topLeftCorner }\n \n\n```","files":null},{"type":6,"timestamp":1732878428,"nonce":"5L8skJ4L5QFCxjW1WDdatpvuGio=","metadata":{"github-id":"UCE_lALOJl1IZM6Vdei0zlZkwv0"},"target":"2baad5ddebcec5860d9f8fa16916e37b492c25946eee7219dff1c32760b451a3","message":"The only case when `restoreClosedWindowsCacheIfNeeded` is called is when macOS decides to reuse window ID from the previously closed window for the newly opened window. The only reasonable case known to me when it might happen is when you lock/unlock the screen. (when you lock and unlock the screen, from macOS APIs POV, windows technically \"close\" and then automatically reopen when you unlock the screen with the same window IDs). AeroSpace relies on that fact that window IDs are reused to restore windows to where they were before you locked the screen.\n\nThat's why it's weird for me to hear that people observe the crash when they unplug the dock. I'm curious to know what window died and then restored its window ID (probably it some sort of synthetic window) and why the hell macOS do this? Or it all could be just a manifistation of another bug in AeroSpace.\n\nYou can try to debug the following, if you observe the crash in cases other than lock/unlock the screen:\n```diff\ndiff --git a/Sources/AppBundle/tree/MacWindow.swift b/Sources/AppBundle/tree/MacWindow.swift\nindex 321fa2b..11a126e 100644\n--- a/Sources/AppBundle/tree/MacWindow.swift\n+++ b/Sources/AppBundle/tree/MacWindow.swift\n@@ -63,7 +63,11 @@ final class MacWindow: Window, CustomStringConvertible {\n     // skipClosedWindowsCache is an optimization when it's definitely not necessary to cache closed window.\n     //                        If you are unsure, it's better to pass `false`\n     func garbageCollect(skipClosedWindowsCache: Bool) {\n-        if !skipClosedWindowsCache { cacheClosedWindowIfNeeded(window: self) }\n+        if !skipClosedWindowsCache {\n+            // The window will be recorded to closedWindowsCache, to potentially restore it from the cache if it turns out that the reason for closing the window is locking the screen\n+            print(\"--- Window \\(app.name) \\(windowId) is about to die and will be recorded to closedWindowsCache.\")\n+            cacheClosedWindowIfNeeded(window: self)\n+        }\n         if MacWindow.allWindowsMap.removeValue(forKey: windowId) == nil {\n             return\n         }\ndiff --git a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\nindex 1e9539f..8ab361d 100644\n--- a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n+++ b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift\n@@ -50,6 +50,7 @@ func restoreClosedWindowsCacheIfNeeded(newlyDetectedWindow: Window) -\u003e Bool {\n     if !closedWindowsCache.windowIds.contains(newlyDetectedWindow.windowId) {\n         return false\n     }\n+    print(\"--- macOS decided to reuse window ID for this window: \\(newlyDetectedWindow). Normally this should only happen when you lock/unlock the screen. It's your case, right, right?...\")\n     let monitors = monitors\n     let topLeftCornerToMonitor = monitors.grouped { $0.rect.topLeftCorner }\n \n\n```","files":null}]}