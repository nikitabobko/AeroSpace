{"author":{"id":"2d08e4816aca0a07db9878f126b0e7f6d6f1362eb9bc4804be6b33ff8d0a19ec"},"ops":[{"type":3,"timestamp":1725486747,"nonce":"Pm1GnUo70ZWITCub2BqHOqQqp74=","metadata":{"github-id":"IC_kwDOJl1IZM6K5Cg9","github-url":"https://github.com/nikitabobko/AeroSpace/issues/490#issuecomment-2330208317"},"message":"I have just run `./swift-exec-deps/.build/debug/swiftlint --fix --format`. There mainly 2 things I'm not happy with\n\n**(1)** Indented `case` inside `switch`. I strongly believe that `case` should be indented inside `switch`. I understand that Swift standard formatting is different, that's why I enforce this rule with `swiftlint` (note `indented_cases` in `.swiftlint.yml`).\n```diff\ndiff --git a/Sources/AppBundle/command/Command.swift b/Sources/AppBundle/command/Command.swift\nindex d8765112..ce217a60 100644\n--- a/Sources/AppBundle/command/Command.swift\n+++ b/Sources/AppBundle/command/Command.swift\n@@ -121,8 +121,8 @@ enum CommandSubject: Equatable {\n extension EffectiveLeaf {\n     var asCommandSubject: CommandSubject {\n         switch focus.asLeaf {\n-            case .window(let w): .window(w)\n-            case .emptyWorkspace(let w): .emptyWorkspace(w.name)\n+        case .window(let w): .window(w)\n+        case .emptyWorkspace(let w): .emptyWorkspace(w.name)\n         }\n     }\n }\n@@ -130,15 +130,15 @@ extension EffectiveLeaf {\n extension CommandSubject {\n     var windowOrNil: Window? {\n         return switch self {\n-            case .window(let window): window\n-            case .emptyWorkspace: nil\n+        case .window(let window): window\n+        case .emptyWorkspace: nil\n         }\n     }\n \n     var workspace: Workspace {\n         return switch self {\n-            case .window(let window): window.visualWorkspace ?? focus.workspace\n-            case .emptyWorkspace(let workspaceName): Workspace.get(byName: workspaceName)\n+        case .window(let window): window.visualWorkspace ?? focus.workspace\n+        case .emptyWorkspace(let workspaceName): Workspace.get(byName: workspaceName)\n         }\n     }\n }\n         return command\n```\n\n**(2)** Multiline conditions in `if` (more important) and multiline expressions/call-chain in general (less important). Additional indentation in multiline `if` condition helps to distinguish it from \"then\" block.\n\n```diff\ndiff --git a/Sources/AppBundle/GlobalObserver.swift b/Sources/AppBundle/GlobalObserver.swift\nindex 68994eac..8ae6e437 100644\n--- a/Sources/AppBundle/GlobalObserver.swift\n+++ b/Sources/AppBundle/GlobalObserver.swift\n@@ -9,10 +9,10 @@ class GlobalObserver {\n         refreshSession(body: {\n             if TrayMenuModel.shared.isEnabled \u0026\u0026 config.automaticallyUnhideMacosHiddenApps {\n                 if let w = prevFocus?.windowOrNil,\n-                        w.macAppUnsafe.nsApp.isHidden,\n-                        // \"Hide others\" (cmd-alt-h) -\u003e don't force focus\n-                        // \"Hide app\" (cmd-h) -\u003e force focus\n-                        MacApp.allAppsMap.values.filter({ $0.nsApp.isHidden }).count == 1 {\n+                   w.macAppUnsafe.nsApp.isHidden,\n+                   // \"Hide others\" (cmd-alt-h) -\u003e don't force focus\n+                   // \"Hide app\" (cmd-h) -\u003e force focus\n+                   MacApp.allAppsMap.values.filter({ $0.nsApp.isHidden }).count == 1 {\n                     // Force focus\n                     _ = w.focusWindow()\n                     _ = w.nativeFocus()\ndiff --git a/Sources/AppBundle/focus.swift b/Sources/AppBundle/focus.swift\nindex 5fc3d8cd..d7678fb4 100644\n--- a/Sources/AppBundle/focus.swift\n+++ b/Sources/AppBundle/focus.swift\n@@ -40,8 +40,8 @@ struct FrozenFocus: AeroAny, Equatable {\n         let windowId = windowId\n         let window: Window? = if let windowId {\n             isUnitTest\n-                ? Workspace.all.flatMap { $0.allLeafWindowsRecursive }.first(where: { $0.windowId == windowId })\n-                : MacWindow.allWindowsMap[windowId]\n+            ? Workspace.all.flatMap { $0.allLeafWindowsRecursive }.first(where: { $0.windowId == windowId })\n+            : MacWindow.allWindowsMap[windowId]\n         } else {\n             nil\n         }\ndiff --git a/Sources/AppBundle/layout/refresh.swift b/Sources/AppBundle/layout/refresh.swift\nindex 7cc81aa8..09ffced2 100644\n--- a/Sources/AppBundle/layout/refresh.swift\n+++ b/Sources/AppBundle/layout/refresh.swift\n@@ -80,9 +80,9 @@ private func layoutWorkspaces() {\n \n         let corner: OptimalHideCorner =\n             monitors.contains(where: { m in m.rect.contains(brc1) || m.rect.contains(brc2) || m.rect.contains(brc3) }) \u0026\u0026\n-                monitors.allSatisfy({ m in !m.rect.contains(blc1) \u0026\u0026 !m.rect.contains(blc2) \u0026\u0026 !m.rect.contains(blc3) })\n-                ? .bottomLeftCorner\n-                : .bottomRightCorner\n+            monitors.allSatisfy({ m in !m.rect.contains(blc1) \u0026\u0026 !m.rect.contains(blc2) \u0026\u0026 !m.rect.contains(blc3) })\n+            ? .bottomLeftCorner\n+            : .bottomRightCorner\n         monitorToOptimalHideCorner[monitor.rect.topLeftCorner] = corner\n     }\ndiff --git a/Sources/AppBundle/mouse/moveWithMouse.swift b/Sources/AppBundle/mouse/moveWithMouse.swift\nindex 6fe8a009..0e22bbde 100644\n--- a/Sources/AppBundle/mouse/moveWithMouse.swift\n+++ b/Sources/AppBundle/mouse/moveWithMouse.swift\n@@ -9,19 +9,19 @@ func movedObs(_ obs: AXObserver, ax: AXUIElement, notif: CFString, data: UnsafeM\n \n private func moveWithMouseIfTheCase(_ window: Window) { // todo cover with tests\n     if window.isHiddenViaEmulation || // Don't allow to move windows of hidden workspaces\n-            !isLeftMouseButtonPressed ||\n-            currentlyManipulatedWithMouseWindowId != nil \u0026\u0026 window.windowId != currentlyManipulatedWithMouseWindowId ||\n-            getNativeFocusedWindow(startup: false) != window {\n+        !isLeftMouseButtonPressed ||\n+        currentlyManipulatedWithMouseWindowId != nil \u0026\u0026 window.windowId != currentlyManipulatedWithMouseWindowId ||\n+        getNativeFocusedWindow(startup: false) != window {\n         return\n     }\ndiff --git a/Sources/AppBundle/tree/MacApp.swift b/Sources/AppBundle/tree/MacApp.swift\nindex 6cdffe2e..981aba6d 100644\n--- a/Sources/AppBundle/tree/MacApp.swift\n+++ b/Sources/AppBundle/tree/MacApp.swift\n@@ -22,7 +22,7 @@ final class MacApp: AbstractApp {\n             let app = MacApp(nsApp, AXUIElementCreateApplication(nsApp.processIdentifier))\n \n             if app.observe(refreshObs, kAXWindowCreatedNotification) \u0026\u0026\n-                    app.observe(refreshObs, kAXFocusedWindowChangedNotification) {\n+                app.observe(refreshObs, kAXFocusedWindowChangedNotification) {\n                 allAppsMap[pid] = app\n                 return app\n             } else {\ndiff --git a/Sources/AppBundle/TrayMenuModel.swift b/Sources/AppBundle/TrayMenuModel.swift\nindex e4d0f8c7..0c4fc270 100644\n--- a/Sources/AppBundle/TrayMenuModel.swift\n+++ b/Sources/AppBundle/TrayMenuModel.swift\n@@ -15,8 +15,8 @@ func updateTrayText() {\n     let sortedMonitors = sortedMonitors\n     TrayMenuModel.shared.trayText = (activeMode?.takeIf { $0 != mainModeId }?.first?.lets { \"[\\($0)] \" } ?? \"\") +\n         sortedMonitors\n-            .map {\n-                ($0.activeWorkspace == focus.workspace \u0026\u0026 sortedMonitors.count \u003e 1 ? \"*\" : \"\") + $0.activeWorkspace.name\n-            }\n-            .joined(separator: \" │ \")\n+        .map {\n+            ($0.activeWorkspace == focus.workspace \u0026\u0026 sortedMonitors.count \u003e 1 ? \"*\" : \"\") + $0.activeWorkspace.name\n+        }\n+        .joined(separator: \" │ \")\n }\n```\n\n---\n\nLooking at https://github.com/swiftlang/swift-format/blob/main/Documentation/Configuration.md, it appears that `swift-lint` doesn't allow to configure either of these.","files":null}]}