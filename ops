{"author":{"id":"3f9f4164bd119a50f8c1c453ac4e7e4609212593fb5fb53b1f5f81664e5c3851"},"ops":[{"type":1,"timestamp":1728036884,"nonce":"zkwCCLS3rTy+S5aPjA7RgEliP6M=","metadata":{"github-id":"I_kwDOJl1IZM6Y8iml","github-url":"https://github.com/nikitabobko/AeroSpace/issues/560","origin":"github"},"title":"Feature Request: Embedded script language","message":"I'd like to discuss embedding a scripting language into AeroSpace to enable more flexible customization and configuration. Currently, AeroSpace supports limited \"dynamic\" behavior, such as the `on-window-detected` callback with a matcher. However, there's a growing need for more advanced conditional behavior (see #278). Instead of turning TOML into a pseudo-programming language, would it make sense to support scripting directly?\n\n**Does this feature align with the project's values?**\n\nIf the answer is yes, then I'd like to discuss the following questions:\n\n**Which scripting language would be the best fit?**\n\nTwo options come to mind:\n\n- **Lua**: A battle-tested language with a lightweight interpreter and a robust ecosystem. It's used in many applications, like Neovim.\n- [**JavaScriptCore**](https://developer.apple.com/documentation/javascriptcore): Built directly into macOS's SDK, with no extra dependencies. It supports JIT compilation (though this requires [specific permissions](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_cs_allow-jit)) and is fully sandboxed. However, it lacks built-in functionality to import other JavaScript files. (e.g. you need to implement all your config in one JS file, or some custom require functionality must be added)\n\nThere is also a Lua 5.1 JIT implementation, though there are known performance issues on aarch64: https://github.com/LuaJIT/LuaJIT/issues/285\n\n**What features should the API support?**\n\nSome of my ideas:\n\n- Setting and modifying config values.\n- Dynamic config values (functions that return values on access).\n- Callbacks to execute functions.\n- Querying windows, monitors, workspaces, etc.\n- Custom layouts.\n- Custom formatters for the tray mode text.\n\n**My current probe/research**\n\nI have the same issue as #60, and I wanted more generic solution, so I have been probing/researching how well Lua fits into AeroSpace's current architecture, and I had promising results. Some of my testing can be found in my `probe-lua` [branch](https://github.com/Henkru/AeroSpace/tree/lua-probe). Lua integrates smoothly with the current config and callback system. For example, I implemented dynamic gaps for my ultrawide monitor:\n\n```lua\nlocal gaps = {\n\t-- [window count] = gap value\n\t[1] = 1280, -- 5120 / 4\n\t[2] = 640, -- 5120 / 8\n\tenabled = true,\n}\nlocal default_gap = 5\n\nlocal dynamic_gap = function(_id, monitor)\n\t-- if monitor.name == \"Dell U4919DW\" then\n\tif monitor.width \u003e 5000 and gaps.enabled then\n\t\tlocal window_count = aero.api.workspace_windows_count(monitor.activeWorkspace)\n\t\treturn gaps[window_count] or default_gap\n\tend\n\treturn default_gap\nend\n\n-- Set static gap for top and bottom\naero.api.gap_set(GAP_OUTER_TOP, 5)\naero.api.gap_set(GAP_OUTER_BOTTOM, 2)\n-- Set dynamic gap for left and right\naero.api.gap_set(GAP_OUTER_LEFT, dynamic_gap)\naero.api.gap_set(GAP_OUTER_RIGHT, dynamic_gap)\n\n-- Toggle the dynamic gap on/off, and then go back to the main mode\naero.keymap.set(\"service\", \"g\", function()\n\tgaps.enabled = not gaps.enabled\nend, \"mode main\")\n```\n\nThe branch implements a lightweight Lua 5.1 wrapper for Swift (chosen for easy switch to LuaJIT) and abstractions for adding new API functions with type-checked parameters. However, it has evolved organically (based on what I currently needed to implement feature X), so the wrapper needs some refactoring/remodeling; for example, the error handling is pretty much via the `error` function that kills the app.\n\nSupported features:\n\n- Setting common config options.\n- Setting/removing key bindings.\n- Executing Aero commands (as strings).\n- Adding Aero callbacks (Lua functions or Aero command strings).\n- Dynamic config values for gaps.\n- Some functions for querying the current state (e.g., window count).\n\nThe currently implemented API functions can be found:\n- `aero.api`: https://github.com/Henkru/AeroSpace/blob/lua-probe/Sources/AppBundle/script/api.swift\n- `aero.callbacks`: https://github.com/Henkru/AeroSpace/blob/lua-probe/Sources/AppBundle/script/callbacks.swift\n- `aero.config`: https://github.com/Henkru/AeroSpace/blob/lua-probe/Sources/AppBundle/script/configApi.swift\n- `aero.keymap`: https://github.com/Henkru/AeroSpace/blob/lua-probe/Sources/AppBundle/script/keymap.swift\n\nAreas for improvement:\n- Returning structured data (as Lua tables) from Aero commands. Currently, all commands return strings.\n\nFor a more [comprehensive example](https://gist.github.com/Henkru/358c8e981dfd1e6635eaac53ba559e18), I fully implemented my current configuration in Lua to showcase what can be done.","files":null}]}