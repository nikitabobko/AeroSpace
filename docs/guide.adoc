= AeroSpace Guide
include::util/site-attributes.adoc[]
:url-search-for-config: https://github.com/search?q=path%3A*aerospace.toml&type=code

include::util/header.adoc[]

We recommend reading this guide in full to understand how to best utilise AeroSpace.

[#installation]
== Installation

[#homebrew-installation]
=== https://brew.sh[Homebrew] (recommended)

[source,bash]
----
brew install --cask nikitabobko/tap/aerospace
----

AeroSpace provides shell completions for bash, fish, and zsh. See https://docs.brew.sh/Shell-Completion to manually enable completion support in Homebrew.

You can install any one of our https://github.com/nikitabobko/homebrew-tap/tree/main/Casks[pinned versions]:

[source,bash]
----
brew install --cask nikitabobko/tap/aerospace@0.17.1
----

[#manual-installation]
=== Manual

. Download the latest release from the https://github.com/nikitabobko/AeroSpace/releases[GitHub releases]
. Double-click the downloaded zip file to extract it
. Move `AeroSpace-v$VERSION/AeroSpace.app` to the `/Applications` directory
. *(Optional)* To interact with AeroSpace from the command line, move `AeroSpace-v$VERSION/bin/aerospace` to a directory included in your `$PATH`

==== Troubleshooting

If you encounter the following error when attempting to open AeroSpace:

____
"AeroSpace.app" can't be opened because Apple cannot check it for malicious software.
____

*Option 1: Using the terminal*

[source,bash]
----
xattr -d com.apple.quarantine /Applications/AeroSpace.app
----

*Option 2: Using Finder*

. Navigate `/Applications/AeroSpace.app` in Finder
. Right-click the app and select *Open*
. Confirm that you want to open the app, bypassing the security warning

[#configuring-aerospace]
== Configuring AeroSpace

AeroSpace uses the TOML format for its config file which is both human-readable and supports comments. For more details, refer to the https://toml.io/en/v1.0.0[TOML specification].

[#config-location]
=== Config location

AeroSpace looks for the config file in the following locations:

* `~/.aerospace.toml`
* `+${XDG_CONFIG_HOME}/aerospace/aerospace.toml+`

If `XDG_CONFIG_HOME` is not set, it will default to `~/.config`.

=== Example configs

You can refer to the following config examples:

* <<default-config,Default config>>
* xref:./goodies.adoc#i3-like-config[i3-like config]

Additionally, you can {url-search-for-config}[search for configs on GitHub] for inspiration.

[#default-config]
=== Default config

The default config is included in the documentation and contains all trivial options along with comments. If no custom config is found, AeroSpace will automatically use the default.

If a key is omitted in your custom config, the default value will be used unless explicitly stated otherwise. Notable exceptions include:

* `mode.*.binding`: Defaults to an empty table. You must explicitly define all keyboard bindings and <<binding-modes,binding modes>>.
* `on-focused-monitor-changed`: Defaults to an empty array.
* `exec`: Table, see <<exec-env-vars>> (Note: It's a bit verbose and not included in the `default-config.toml`)

In general, scalar-like values (e.g. strings, numbers) automatically fall back to their default values. Vector-like values (e.g. arrays, tables) will fall back to an empty array or table. This approach allows you to keep your custom config tidy, avoiding the need to repeat preferred default values.

We recommend copying the default config from the application installation as a starting point:

[source,bash]
----
cp /Applications/AeroSpace.app/Contents/Resources/default-config.toml ~/.aerospace.toml
----

link:config-examples/default-config.toml[Download default-config.toml]

[source,toml,subs="macros+,specialchars+"]
----
include::config-examples/default-config.toml[]
----

[#binding-modes]
=== Binding modes
____
This feature mirrors the functionality of https://i3wm.org/docs/userguide.html#binding_modes[i3's binding modes].
____

Binding modes allow you to define multiple sets of key bindings. When you switch to a different binding mode, all the bindings from the current mode are deactivated, and only the bindings specified in the new mode become active. AeroSpace starts in the "main" binding mode by default.

Working with binding modes consists of two parts:

. *Defining a binding* to switch to the binding mode
. *Declaring the binding mode* itself, specifying key bindings that belong to it

==== Example usage

[source,toml]
----
[mode.main.binding]            # Declare 'main' binding mode
    alt-r = 'mode resize'      # 1. Define a binding to switch to 'resize' mode

[mode.resize.binding]          # 2. Declare 'resize' binding mode
    minus = 'resize smart -50'
    equal = 'resize smart +50'
----

In this example:

* The `alt-r` key is defined to switch to the 'resize' mode
* The 'resize' mode has its own set of key bindings (`minus` and `equal`) for resizing windows

[#commands]
=== Commands

Commands are used to manipulate AeroSpace and query its state. There are two ways you can use commands:

. Bind keys to run AeroSpace commands:
+
[source,toml]
----
[mode.main.binding]
    # Bind alt-1 key to switch to workspace 1
    alt-1 = 'workspace 1'
    # Or bind a sequence of commands
    alt-shift-1 = ['move-node-to-workspace 1', 'workspace 1']
----
. Run commands on the command line:
+
[source,bash]
----
aerospace workspace 1
----

For a list of available commands, see xref:commands.adoc[]

[#key-mapping]
=== Keyboard layouts and key mapping

By default, AeroSpace assumes that key bindings are based on the *QWERTY* layout. If you're using a different keyboard layout, alphabet, or simply want to create custom aliases for existing keys, you can map keys using `key-mapping.key-notation-to-key-code`.

[source,toml]
----
# Define a fancy unicorn key notation
[key-mapping.key-notation-to-key-code]
    unicorn = 'u'

[mode.main.binding]
    alt-unicorn = 'workspace wonderland' # (⁀ᗢ⁀)
----

In this example:

* The `unicorn` key is mapped to the `u` key
* The `alt-unicorn` binding is used to trigger `workspace wonderland` command

==== Presets for common layouts

If you use *Dvorak* or *Colemak* layouts, AeroSpace provides built-in presets:

[source,toml]
----
[key-mapping]
    preset = 'dvorak' # or 'colemak'
----

[#exec-env-vars]
=== Environment variables (`exec-*`)

You can configure environment variables for `exec-*` commands and callbacks (e.g. xref:commands.adoc#exec-and-forget[exec-and-forget] or <<exec-on-workspace-change-callback>>).

* `exec.inherit-env-vars`: Determines whether to inherit environment variables from `AeroSpace.app` (default: `true`)
* To override environment variables, use the following syntax:
+
[source,toml]
----
[exec.env-vars]
    PATH = '${HOME}/bin:${PATH}'
----
+
Environment variable substitution is supported using the syntax `+${ENV_VAR}+`. To inspect the final values of your environment variables, use the xref:commands.adoc#list-exec-env-vars[`list-exec-env-vars` command].

By default, GUI apps on macOS lack Homebrew's prefix in their `PATH` (see https://docs.brew.sh/FAQ#my-mac-apps-dont-find-homebrew-utilities[Homebrew documentation]). Unless you override the `exec` section in your config, AeroSpace defaults to the following `exec` settings:

[source,toml]
----
[exec]
    inherit-env-vars = true
[exec.env-vars]
    PATH = '/opt/homebrew/bin:/opt/homebrew/sbin:${PATH}'
----

[#tree]
== Tree

AeroSpace organises all windows and containers in a tree structure, https://i3wm.org/docs/userguide.html#tree[inspired by i3].

NOTE: i3 uses different terminology. What i3 refers to as a "container" is equivalent to a "node" in AeroSpace.

Key concepts:

* Non-leaf nodes are containers
* Each workspace has a single root node
* Containers can have any number of child nodes
* Windows are the only leaf nodes and do not have children
* Every container has these properties:
** *<<layouts,Layout>>*: Determines the arrangement of child noes (`tiles` or `accordion`)
** *Orientation*: Specifies the direction of the layout (`horizontal` or `vertical`)

When referencing the "layout of the window", it pertains to the layout of the window's parent container.

=== Example tree structures

.*Simple tree structure*: Two windows side-by-side
image::assets/h_tiles.png[]

.*Complex tree structure*
image::assets/tree.png[]

Containers can be nested indefinitely. You can navigate the tree in four cardinal directions (left, down, up, right) using the xref:commands.adoc#focus[`focus`] command.

The tree structure can be changed with these commands:

* xref:commands.adoc#move[`move`]
* xref:commands.adoc#join-with[`join-with`]
* xref:commands.adoc#split[`split`] (primarily for compatibility with i3; `join-with` is preferred)

[#layouts]
=== Layouts

AeroSpace supports four layout types:

* `h_tiles`: Horizontal tiles (similar to i3's "horizontal split")
* `v_tiles`: Vertical tiles (similar to i3's "vertical split")
* `h_accordion`: Horizontal accordion (i3's "tabbed layout")
* `v_accordion`: Vertical accordion (i3's "stacked layout")

If you're familiar with the `tiles` layout from the <<tree,Tree>> section, accordions differ by stacking windows atop one another.

* *Horizontal accordion*: Displays left and right padding to peek additional windows
* *Vertical accordion*: Displays top and bottom padding to peek additional windows

.Horizontal accordion
image::assets/h_accordion.png[,800,align="center"]

.Vertical accordion
image::assets/v_accordion.png[,800,align="center"]

Navigation within accordion layouts is similar to tile layouts:

* Use `focus (left|right)` for `h_accordion`
* Use `focus (up|down)` for `v_accordion`

Accordion padding is configurable via the `accordion-padding` option.

[#normalization]
=== Normalization

By default, AeroSpace applies two types of tree normalization:

. *Flattening containers*: Containers with only one child are flattened with the exception of the root container (configured by `enable-normalization-flatten-containers`)
. *Opposite orientation for nested containers*: Containers that nest into each other must have opposing orientations (configured by `enable-normalization-opposite-orientation-for-nested-containers`)

==== Example normalizations

[.lead]
*Example 1: Flattening containers*

Invalid layout:

----
h_tiles (root node)
└── v_tiles
    └── window 1
----

Normalised layout:

----
v_tiles (new root node)
└── window 1
----

[.lead]
*Example 2: Opposite orientations for nested containers*

Invalid layout:

----
h_tiles
├── window 1
└── h_tiles
    ├── window 2
    └── window 3
----

Normalized layout:

----
h_tiles
├── window 1
└── v_tiles
    ├── window 2
    └── window 3
----

Normalization simplifies the tree structure, making it easier to understand window placements. Unless you're an experienced i3 user, it's recommended to keep normalization enabled. To disable normalization:

[source,toml]
----
enable-normalization-flatten-containers = false
enable-normalization-opposite-orientation-for-nested-containers = false
----

[#floating-windows]
=== Floating windows

Floating windows are not part of the <<tree,tiling tree>> but are treated as such when using commands like xref:commands.adoc#focus[`focus`]. The parent container for floating windows is determined by the smallest tiling container containing the window's center. This eliminates the need for separate bindings to focus floating windows.

[#emulation-of-virtual-workspaces]
== Emulation of virtual workspaces

Native macOS Spaces have several limitations:

* Slow animations when switching Spaces, with no option to disable them (the `Reduce motion` accessibility setting improves this only slightly)
* Limited to 16 Spaces per monitor
* No hotkey support for creating, deleting or reordering Spaces, or moving windows between them
* Lack of a public API for interacting with Spaces

AeroSpace reimplements Spaces functionality, calling them "Workspaces". Instead of creating new Spaces, inactive windows are moved off-screen (to the bottom-right or bottom-left corner). When a workspace is reactivated (e.g. using the xref:commands.adoc#workspace[`workspace`] command or `cmd + tab`), its windows are restored to the visible area.

NOTE: AeroSpace's tray icon (top-right corner) displays the currently active workspace.

The ideal workflow involves using a *single macOS Space* (or as many Spaces as you have monitors if the "Displays have separate Spaces" option is enabled). Once AeroSpace is in use, you won't need to interact with macOS Spaces anymore.

=== Managing hidden windows

Since macOS doesn't allow windows to be fully hidden off-screen, a one-pixel vertical line will remain visible at the screen's edge. To minimize this visibility:

* Place the Dock at the bottom
* Enable automatic Dock hiding

If you quit AeroSpace, or if AeroSpace detects an impending crash, all windows will be automatically restored to the visible screen area. In case of failure, you can manually restore windows by dragging the visible edge back to the center of the screean.

=== Monitor arrangement

For optimal performance, ensure every monitor has free space in one of its bottom corners (`System Settings → Displays → Arrange...`).

Examples:

.Bad Monitor Arrangement
image::./assets/monitor-arrangement-1-bad.svg[,,align="center"]

.Good Monitor Arrangement
image::./assets/monitor-arrangement-1-good.svg[,,align="center"]

[#macos-integration]
=== macOS integration

AeroSpace operates by managing windows outside the normal bounds of macOS's windowing system. For the best experience, consider adjusting the following macOS settings:

[#a-note-on-mission-control]
==== Group windows by application

Mission Control doesn't handle off-screen windows well. AeroSpace-managed windows may appear too small or misaligned. Enabling "Group windows by application" helps mitigate this issue.

You can enable it via:

* `System Settings → Desktop & Dock → Mission Control → Group windows by application`
* Or run this in the terminal:
+
[source,bash]
----
defaults write com.apple.dock expose-group-apps -bool true && killall Dock
----

[#a-note-on-displays-have-separate-spaces]
==== Disable "Displays have separate Spaces"

Disabling "Displays have separate Spaces" often results in:

* Fewer focus bugs
* Improved performance
* More consistent multi-monitor behaviour with AeroSpace

You can disable it via:

* `System Settings → Desktop & Dock → Displays have separate Spaces`
* Or run this in the terminal:
+
[source,bash]
----
defaults write com.apple.spaces spans-displays -bool true && killall SystemUIServer
----

NOTE: You may need to log out and back in for this change to take effect.

== Callbacks

Callbacks enable automating actions based on window events, focus changes and more. The callbacks are processed in the order they are declared. If no conditions are specified or matched, the callback will run every time a new window is detected.

By default, the first callback that matches the criteria is run, and further callbacks are not considered. This behaviour can be overridden with the `check-further-callbacks` option.

Please post your use cases to https://github.com/nikitabobko/AeroSpace/issues/20[in this GitHub issue] if you want additional commands to be supported.

[#on-window-detected-callback]
=== 'on-window-detected'

The `on-window-detected` callback runs commands whenever a new window is detected. You can specify conditions to match specific windows and define actions to be executed.

==== Example usage

[source,toml]
----
[[on-window-detected]]
    if.app-id = 'com.apple.systempreferences'
    if.app-name-regex-substring = 'settings'
    if.window-title-regex-substring = 'substring'
    if.workspace = 'workspace-name'
    if.during-aerospace-startup = true
    check-further-callbacks = true
    run = ['layout floating', 'move-node-to-workspace S']
----

In this example:

* The callback matches windows with the specified `app-id`, `app-name`, `window-title` and `workspace`
* The `run` option can execute xref:commands.adoc#layout[`layout`] and xref:commands.adoc#move-node-to-workspace[`move-node-to-workspace`] commands
* The `check-further-callbacks` option allows subsequent callbacks to be processed

Available window conditions are:

[cols="1,2"]
|===
|Condition |Description

|`if.app-id`
|Matches the exact application ID of the detected window

|`if.app-name-regex-substring`
|Matches a case-insensitive substring in the application name

|`if.window-title-regex-substring`
|Matches a case-insensitive substring in the window title

|`if.workspace`
|Matches the exact workspace name of the detected window

|`if.during-aerospace-startup`
|Specifies whether the callback should run only during AeroSpace startup (default: not checked)

|===

IMPORTANT: Some windows set their title after the window appears, causing match issues for `window-title-regex-substring`

[NOTE]
====
* If no conditions are specified, the `run` commands will execute for every new window
* To find an application's `app-id`:
** Refer to our xref:./goodies.adoc#popular-apps-ids[list of popular application IDs]
** Use the xref:commands.adoc#list-apps[`aerospace list-apps`] CLI command to list running application IDs
** Run `mdls -name kMDItemCFBundleIdentifier -r /Applications/<App>.app` for the ID of a specific app
====


==== Example automations

* Assigning apps to specific workspaces:
+
[source,toml]
----
[[on-window-detected]]
    if.app-id = 'org.alacritty'
    run = 'move-node-to-workspace T' # mnemonics T - Terminal

[[on-window-detected]]
    if.app-id = 'com.google.Chrome'
    run = 'move-node-to-workspace W' # mnemonics W - Web browser

[[on-window-detected]]
    if.app-id = 'com.jetbrains.intellij'
    run = 'move-node-to-workspace I' # mnemonics I - IDE
----
* Making all windows float by default:
+
[source,toml]
----
[[on-window-detected]]
    check-further-callbacks = true
    run = 'layout floating'
----

[#on-focus-changed-callbacks]
=== 'on-focus-changed'

AeroSpace provides two callbacks for tracking focus changes:

* `on-focus-changed`: Triggered whenever the focused window or workspace changes
* `on-focused-monitor-changed`: Triggered whenever the focused monitor changes

==== Example usage

You can implement "mouse follows focus" behaviour by combining these callbacks with the xref:commands.adoc#move-mouse[`move-mouse`] command:

[source,toml]
----
on-focused-monitor-changed = ['move-mouse monitor-lazy-center'] # Mouse lazily follows focused monitor (default in i3)
# or
on-focus-changed = ['move-mouse window-lazy-center'] # Mouse lazily follows any focus (window or workspace)
----

[NOTE]
====
* Callbacks are "recursion resistant", meaning focus changes within the callback won't retrigger it
* Changing focus within these callbacks is discouraged and may behave differently in future versions
====

[#exec-on-workspace-change-callback]
=== 'exec-on-workspace-change'

The `exec-on-workspace-change` callback allows you to run custom processes whenever the focused workspace changes. This is particularly useful for integrations with status bars or notification systems.

==== Example usage

[source,toml]
----
# Notify Sketchybar about workspace changes
exec-on-workspace-change = ['/bin/bash', '-c',
    'sketchybar --trigger aerospace_workspace_change FOCUSED=$AEROSPACE_FOCUSED_WORKSPACE'
]
----

==== Environment variables

In addition to <<exec-env-vars,`exec.env-vars`>>, the process has access to the following environment variables:

* `AEROSPACE_FOCUSED_WORKSPACE`: The workspace the user switched to
* `AEROSPACE_PREV_WORKSPACE`: The workspace the user switched from

For a detailed example of integrating with Sketchybar, see xref:./goodies.adoc#show-aerospace-workspaces-in-sketchybar[]

[#multiple-monitors]
== Multiple monitors

AeroSpace supports multiple monitors with a shared pool of workspaces. To manage this, AeroSpace follows a few key rules:

* The workspace pool is shared between monitors
* Each monitor shows its own workspace, referred to as a "visible" workspace
* Workspaces are exclusive per monitor—two monitors cannot display the same workspace at the same time
* Every workspace (including empty or hidden ones) has a monitor assigned to it
* By default, all workspaces are assigned to the "main" monitor (as defined in `System Settings → Displays → Use as`)

=== Switching workspaces

When you switch to a workspace:

. AeroSpace moves it to its assigned monitor and makes it visible
. The workspace is focused

To move a workspace to a different monitor, use the xref:commands.adoc#move-workspace-to-monitor[`move-workspace-to-monitor`] command.

=== Why share the workspace pool?

The idea of sharing the workspace pool is based on the [#observation]observation that most users have a limited set of workspaces on their secondary monitors. Secondary monitors are often dedicated to specific tasks such as running a browser, terminal or monitoring logs. Therefore, using one workspace per secondary monitor and placing the rest on the main monitor is often a good fit.

[NOTE]
====
The only major behavioural difference between AeroSpace and i3 is how empty workspaces are handled:

* i3 places the empty workspace on the _currently active_ monitor
* AeroSpace places it on the workspace's _assigned_ monitor (consistent between empty and non-empty workspaces)
====

[#assign-workspaces-to-monitors]
=== Assigning workspaces to monitors

You can use the `workspace-to-monitor-force-assignment` setting to control where workspaces appear:

[source,toml]
----
[workspace-to-monitor-force-assignment]
    1 = 1                            # Monitor sequence from left to right (1-based indexing)
    2 = 'main'                       # Main monitor
    3 = 'secondary'                  # Non-main monitor (when using two monitors)
    4 = 'built-in'                   # Case-insensitive regex substring
    5 = '^built-in retina display$'  # Case-insensitive regex match
    6 = ['secondary', 'dell']        # First matching pattern is used
----

* The *key* is the workspace name or number
* The *value* is a monitor identifier or pattern

==== Supported monitor patterns:

* `main`: The main display (as defined in macOS settings)
* `secondary`: A non-main monitor (used only when two monitors are connected)
* `<number>` (e.g. `1`, `2`): Left-to-right sequence number (1-based)
* `<regex-pattern>` (e.g. `+dell.*+`, `+built-in.*+`): Matches monitor names (case-insensitive)

If a workspace has a forced monitor assignment, the xref:commands.adoc#move-workspace-to-monitor[`move-workspace-to-monitor`] command will have no effect on it.

== Dialog heuristics

macOS provides an accessibility API for identifying dialog windows, but many apps either don't use it correctly or at all. Even some Apple apps (like Finder’s "Copy" progress window) fail to mark dialogs properly. AeroSpace uses the API when available but also applies additional heuristics to identify dialogs.

=== Heuristic rules

* Windows without a fullscreen button are treated as dialogs, excluding terminal apps (e.g. WezTerm, Alacritty, iTerm2)
* Dialogs are floated by default

If a window isn't recognized correctly, you're welcome to contribute a fix. Hardcoding special handling for popular apps is acceptable and what AeroSpace already does. See the `isDialogHeuristic` function in the source code.

=== Manually forcing tiling or floating

You can explicitly control window layout using `on-window-detected`:

* Force tile all windows (or by app)
+
[source,toml]
----
[[on-window-detected]]
    if.app-id = '...'
    run = 'layout tiling'
----
* Force float all windows (or by app)
+
[source,toml]
----
[[on-window-detected]]
    if.app-id = '...'
    run = 'layout floating'
----

== Common pitfalls

=== Key bindings not registering

If some keys in your AeroSpace config aren't working, ensure they are not being overridden by other software like `skhd`, Karabiner-Elements, or Raycast.
